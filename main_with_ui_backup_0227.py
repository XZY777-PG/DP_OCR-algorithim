# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '/home/psic/Documents/Deadpile_python_project/test.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import datetime,traceback,sys,cv2,time,logging,re,random
from math import isnan
from Modules import plc as plc
import pandas as pd
from Modules import basler_camera as camera
from Modules import ocrModule as ocr_ai
from Modules.thread3_calculate_sorter_output import calculate_sorter_output
from Modules.thread5_accumulated_cnt_and_sorter_release import accumulated_cnt_and_sorter_release
from UI_MainWindow_backup0227 import Ui_MainWindow


import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)

df_user_congfigure = pd.DataFrame(columns = ['user','password','user_level'],data =[['admin','admin',1],['test_user_1','admin',2] ,['test_user_2','admin',2]])

df1_ocr_sort_info = pd.DataFrame(columns=['serial_num', 'sensor_on_tm','image_capture_tm', 'ocr_finish_tm',

                                         'fpc_batch','ocr_result', 'sorter_output',

                                         'backup_output', 'sorter_enter_tm',

                                         'sorter_success_enter', 'success_sort'])

thread2_ocr_ai_thread_id = 0
#df1_ocr_sort_info.set_index('serial_num', inplace=True)  # make the type as index, then easy to retrieve the data

df2_fpc_batch_summary  = pd.DataFrame(columns=['fpc_batch', 'target_qty', 'actual_qty','completion', 'last_enter_tm', 'waited_tm', 'sorter_output'])

#df2_fpc_batch_summary.set_index('fpc_batch', inplace=True)  # make the type as index, then easy to retrieve the data

df3_sorter_output_status = pd.DataFrame(columns=['sorter_output', 'logic_available', 'physical_available',

                                                'previous_fpc', 'output_available'])

df3_sorter_output_status['sorter_output'] = ['1','2','3','4','5','6','7']

df3_sorter_output_status['logic_available'] = [False,True,True,True,True,True,True]

df3_sorter_output_status['physical_available'] = [True,True,True,True,True,True,True]

df3_sorter_output_status['output_available'] = [True,True,True,True,True,True,True]



#df_sorter_output_status.set_index('sorter_output', inplace=True)  # make the type as index, then easy to retrieve the data

def plc_connect(ip_address, connect_type):
    try:
        siemens_plc = plc.plc_connect(ip_address, connect_type)

        return siemens_plc

    except Exception:
        print(traceback.print_exc())

        return False

def fuzzy_match(ocr_fpc_list, ocr_batch_list, conf_level=0.7) -> (str, str):
    global df2_fpc_batch_summary
    
    df2_copy = df2_fpc_batch_summary.iloc[:-1,:]

    # 最长公共字符串计算函数
    

    def longest_common_subsequence(s1: str, s2: str):
        m = len(s1)
        n = len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 特殊字符匹配关系
                if s1[i - 1] == s2[j - 1] or \
                    (s1[i - 1] == 'B' and s2[j - 1] == '8') or \
                    (s1[i - 1] == 'B' and s2[j - 1] == '3') or \
                    (s1[i - 1] == 'D' and s2[j - 1] == '0') or \
                    (s1[i - 1] == '8' and s2[j - 1] == '3') or \
                    (s1[i - 1] == 'G' and s2[j - 1] == '6') or \
                    (s1[i - 1] == 'G' and s2[j - 1] == '8') or \
                    (s1[i - 1] == 'G' and s2[j - 1] == '0') or \
                    (s1[i - 1] == '4' and s2[j - 1] == 'A') or \
                    (s1[i - 1] == '2' and s2[j - 1] == 'Z') or \
                    (s1[i - 1] == 'L' and s2[j - 1] == '1') or \
                    (s1[i - 1] == '1' and s2[j - 1] == 'T') or \
                    (s1[i - 1] == 'C' and s2[j - 1] == '0') or \
                    (s1[i - 1] == 'C' and s2[j - 1] == '5') or \
                    (s1[i - 1] == 'C' and s2[j - 1] == '6') or \
                    (s1[i - 1] == '0' and s2[j - 1] == 'Q') or \
                    (s1[i - 1] == '5' and s2[j - 1] == 'S'):

                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]

    res_fpc = 'others'
    # Scenario 1: 无fpc, 无batch
    if len(ocr_fpc_list) == 0 and len(ocr_batch_list) == 0:
        return 'others'

    # Scenario 2: 无fpc
    elif len(ocr_fpc_list) == 0:

        max_lcs_length_batch = 0
        for index, row  in df2_copy.iterrows():
            fpc_batch = row['fpc_batch']
            str_fpc_batch = str(fpc_batch).split('_')
            fpc = str_fpc_batch[0]
            batch = str_fpc_batch[1]
            for ocr_batch in ocr_batch_list:
                curr_lcs_length_batch = longest_common_subsequence(batch, ocr_batch)
                if curr_lcs_length_batch > max_lcs_length_batch:
                    res_batch = batch
                    res_fpc = fpc
                    max_lcs_length_batch = curr_lcs_length_batch

    # Scenario 3: 无batch
    elif len(ocr_batch_list) == 0:

        max_lcs_length_fpc = 0
        for index, row  in df2_copy.iterrows():
            fpc_batch = row['fpc_batch']
            str_fpc_batch = str(fpc_batch).split('_')
            fpc = str_fpc_batch[0]
            batch = str_fpc_batch[1]
            for ocr_fpc in ocr_fpc_list:
                curr_lcs_length_fpc = longest_common_subsequence(fpc, ocr_fpc)
                if curr_lcs_length_fpc > max_lcs_length_fpc:
                    res_batch = batch
                    res_fpc = fpc
                    max_lcs_length_fpc = curr_lcs_length_fpc

    # Scenario 4: fpc, batch都有
    else:

        max_lcs_length_fpc = 0
        max_lcs_length_batch = 0
        for index, row  in df2_copy.iterrows():
            fpc_batch = row['fpc_batch']
            str_fpc_batch = str(fpc_batch).split('_')
            fpc = str_fpc_batch[0]
            batch = str_fpc_batch[1]
            for ocr_fpc in ocr_fpc_list:
                for ocr_batch in ocr_batch_list:
                    curr_lcs_length_fpc = longest_common_subsequence(fpc, ocr_fpc)
                    curr_lcs_length_batch = longest_common_subsequence(batch, ocr_batch)
                    if curr_lcs_length_fpc > max_lcs_length_fpc:
                        res_fpc = fpc
                        res_batch = batch
                        max_lcs_length_fpc = curr_lcs_length_fpc
                        max_lcs_length_batch = curr_lcs_length_batch
                    elif curr_lcs_length_fpc == max_lcs_length_fpc and curr_lcs_length_batch > max_lcs_length_batch:
                        res_fpc = fpc
                        res_batch = batch
                        max_lcs_length_batch = curr_lcs_length_batch
    
    unique_pass = False
    counter = 0
    for index, row in df2_copy.iterrows():
        if res_fpc == row['fpc_batch'].split('_')[0]:
            counter += 1
    if counter == 1:
        unique_pass = True

    if len(ocr_fpc_list) > 0:
        fpc_pass = max_lcs_length_fpc / len(res_fpc) >= conf_level
    else:
        fpc_pass = False

    if len(ocr_batch_list) > 0:
        batch_pass = max_lcs_length_batch / len(res_batch) >= conf_level
    else:
        batch_pass = False
    


    if batch_pass or ((not batch_pass) and fpc_pass and unique_pass):
        #2023 01 05 修改 返回 fpc_batch
        #return res_fpc, res_batch
        fpc_batch = res_fpc + '_' + res_batch
        return fpc_batch
    else:
        return 'others'
    
def load_ai_module(path, bath_size, anchor_sizes, anchor_ratios, num_classes, accept_score):
    return ocr_ai.load_predictor(path, bath_size, anchor_sizes, anchor_ratios, num_classes, accept_score)

class pandasModel(QtCore.QAbstractTableModel):

    def __init__(self, data):
        QtCore.QAbstractTableModel.__init__(self)
        self._data = data

    def rowCount(self, parent=None):
        return len(self._data.index)
        #return self._data.shape[0]

    def columnCount(self, parnet=None):
        return self._data.shape[1]

    def data(self, index, role=QtCore.Qt.DisplayRole):

        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None
        '''
        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None
        '''

    def headerData(self, col, orientation, role):
        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
            return self._data.columns[col]
        return None

class thread1_ocr_plc_message(QtCore.QThread):

    button_generate_case_visable = QtCore.pyqtSignal(bool)

    thread1_status = QtCore.pyqtSignal(bool)

    thread1_error_message = QtCore.pyqtSignal(object)
    

    def __init__(self):
        super(thread1_ocr_plc_message, self).__init__()
        print('thread1 init sucess')
        self.isRunning = False
        self.plc_ip_address = None
        self.plc_connect_type = None
        self.thread_Mode = None
        self.serial_num = None 
        self.generate_case = False

    def run(self):
        #
        # update_ocr_sort_info_new_case()
        self.isRunning = True
        global df1_ocr_sort_info
        program_run_once = True
        #now = datetime.datetime.now()
        #image_capture_tm = now.strftime("%Y%m%d%H%M%S")
        if self.thread_Mode == 3:
            try:
                _plc_ocr = plc.plc_connect(self.plc_ip_address,self.plc_connect_type)
                plc.write_bool(_plc_ocr, 1, 2, 1)
                plc_connect_success = True
            except Exception as e:
                self.thread1_error_message.emit(e)
                self.isRunning = False
                plc_connect_success = False

        

        self.thread1_status.emit(self.isRunning)
           
        if self.thread_Mode == 3 and plc_connect_success == True:
                
            while self.isRunning:

                time.sleep(0.001)
                
                try:

                    if plc.read_bool(_plc_ocr,1,3) and not plc.read_bool(_plc_ocr,1,4):

                        sensor_on_tm = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

                        new_row = pd.Series({'serial_num': self.serial_num, 'sensor_on_tm': sensor_on_tm}) 

                        df1_ocr_sort_info = pd.concat([df1_ocr_sort_info, new_row.to_frame().T], ignore_index=True)     

                                          

                        plc.write_bool(_plc_ocr, 1, 4, 1)

                        print(df1_ocr_sort_info)

                    elif not plc.read_bool(_plc_ocr, 1, 3) and plc.read_bool(_plc_ocr, 1, 4):

                        plc.write_bool(_plc_ocr, 1, 4, 0)
                    
                    if plc.read_bool(_plc_ocr, 1, 1) and not plc.read_bool(_plc_ocr, 1, 2) and len(df1_ocr_sort_info) > self.serial_num:

                        image_capture_tm = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

                        df1_ocr_sort_info.loc[self.serial_num,'image_capture_tm'] = image_capture_tm

                        self.serial_num += 1 
                        
                        plc.write_bool(_plc_ocr, 1, 2, 1)

                        print(df1_ocr_sort_info)
                            
                        # new_case_info.start()
                    elif not plc.read_bool(_plc_ocr, 1, 1) and plc.read_bool(_plc_ocr, 1, 2):

                        plc.write_bool(_plc_ocr, 1, 2, 0)

                        program_run_once = True

                        
                    
                except Exception as e:
                    
                    e = 'Thread1 Stopped' + str(e)
                    self.thread1_error_message.emit(e)
                    print(traceback.print_exc())
                  
                    plc_connect_success = False
                    break
            
        if self.thread_Mode == 1:
            
            while self.isRunning:

                time.sleep(0.001)

                self.button_generate_case_visable.emit(True)

                if self.generate_case:

                    sensor_on_tm = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

                    new_row = pd.Series({'serial_num': self.serial_num, 'sensor_on_tm': sensor_on_tm}) 

                    df1_ocr_sort_info = pd.concat([df1_ocr_sort_info, new_row.to_frame().T], ignore_index=True)     

                    

                    self.generate_case = False
                
                if len(df1_ocr_sort_info) > self.serial_num and \
                 (datetime.datetime.now() - datetime.datetime.strptime(df1_ocr_sort_info.loc[self.serial_num,'sensor_on_tm'],"%Y-%m-%d %H:%M:%S:%f")).microseconds > random.randint(300000,600000) :
                    
                                         
                    image_capture_tm = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

                    df1_ocr_sort_info.loc[self.serial_num,'image_capture_tm'] = image_capture_tm

                    self.serial_num += 1 
                      

        if self.thread_Mode!= 1 and plc_connect_success == True:

            plc.plc_con_close(_plc_ocr)
        
        if self.thread_Mode == 1 :
            self.button_generate_case_visable.emit(False)

        self.isRunning = False

        self.thread1_status.emit(self.isRunning)

    
    def stop(self):

        self.isRunning = False

class thread2_ocr_ai_thread(QtCore.QThread):

        new_image_name = QtCore.pyqtSignal(str)

        update_df1_ocr_sort_info = QtCore.pyqtSignal(object)

        ocr_result = QtCore.pyqtSignal(object)

        image_ocr_result = QtCore.pyqtSignal(str)

        thread2_error_message = QtCore.pyqtSignal(object)

        thread2_status = QtCore.pyqtSignal(bool)

        

        def __init__(self):

            super(thread2_ocr_ai_thread, self).__init__()

            print('thread2 init sucess')

            self.predictor = None

            self.reader = None

            self.camera = None

            self.ocr_ai_thread_id = None

            self.thread_Mode = None
                   
        def run(self):

            global df1_ocr_sort_info

            global thread2_ocr_ai_thread_id 

            self.ocr_ai_thread_id = 0

            self.isRunning = True

            self.thread2_status.emit(self.isRunning)

            camera_connect_success = False

            if self.thread_Mode == 3:
                try:
                   
                    _camera = camera.camera_connect(self.camera)

                    camera_connect_success = True

                except Exception as e:

                    self.thread2_error_message.emit(e)

                    self.isRunning = False

                    camera_connect_success = False

                while self.isRunning:

                    

                    time.sleep(0.001)
                    
                    try:

                        if df1_ocr_sort_info.shape[0] > self.ocr_ai_thread_id and not pd.isna(df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'image_capture_tm']):
                            
                            

                            image_capture_tm = df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'image_capture_tm']

                            sensor_off_time = datetime.datetime.strptime(image_capture_tm, '%Y-%m-%d %H:%M:%S:%f')
                        
                    
                            if (datetime.datetime.now() - sensor_off_time).microseconds >= 750000:

                                thread2_start_time = datetime.datetime.now()
                                
                                #time.sleep(0.0001)

                                '''
                                1. 触发相机拍照
                                '''
                                image, teat = camera.camera_grap_image(self.camera)

                                '''
                                2. 存图
                                '''
                                
                                cv2.imwrite('pic/pic_camera/' + sensor_off_time.strftime("%Y%m%d%H%M%S%f")[:-3] + '.jpeg', image)

                                new_image_name = sensor_off_time.strftime("%Y%m%d%H%M%S%f")[:-3] + '.jpeg'

                                self.new_image_name.emit(new_image_name)

                                '''
                                3.ocr 推导
                                '''
                                ocr_result = ocr_ai.infer_image_phase1aphase2(self.predictor, self.reader, image, new_image_name)

                                self.ocr_result.emit(ocr_result)

                                #self.image_ocr_result.emit(new_image_name)

                                now = datetime.datetime.now()

                                ocr_finish_tm = now.strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

               
                                ocr_fuzzy_match = fuzzy_match(ocr_result[0], ocr_result[1], 0.9)

                                if ocr_fuzzy_match == 'others' :

                                    cv2.imwrite('pic/error_png/' + sensor_off_time.strftime("%Y%m%d%H%M%S%f")[:-3] + '.jpeg', image)

                                ocr_result_str = '' 

                                for item in ocr_result:

                                    for str in item:

                                        ocr_result_str = ocr_result_str +'_' + str
                                        
                                df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'ocr_result'] = ocr_result_str
                               
                                df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'ocr_finish_tm'] = ocr_finish_tm                             

                                df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'fpc_batch'] = ocr_fuzzy_match

                                self.update_df1_ocr_sort_info.emit(df1_ocr_sort_info)
                                
                                self.ocr_ai_thread_id += 1    

                                print('thread2_time:',datetime.datetime.now()  -thread2_start_time)          

                                
                    except Exception as e:
                        print(traceback.print_exc())

                        self.thread2_error_message.emit(e)

                        self.isRunning = False
           
            if self.thread_Mode == 1:

                global df2_fpc_batch_summary

                while self.isRunning:

                    time.sleep(0.001)

                    try:

                        now = datetime.datetime.now()

                        if df1_ocr_sort_info.shape[0] > self.ocr_ai_thread_id and not pd.isna(df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'image_capture_tm']):

                            image_capture_tm = df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'image_capture_tm']

                            sensor_off_time = datetime.datetime.strptime(image_capture_tm, '%Y-%m-%d %H:%M:%S:%f')

                            if (datetime.datetime.now() - sensor_off_time).microseconds >= 750000:

                                random_fpc_batch = df2_fpc_batch_summary.loc[random.randint(0,df2_fpc_batch_summary.shape[0]-1)]['fpc_batch']
                                
                                time.sleep(random.random())

                                ocr_finish_tm = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S:%f')[:-3]

                                df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'ocr_finish_tm'] = ocr_finish_tm                           

                                df1_ocr_sort_info.loc[self.ocr_ai_thread_id, 'fpc_batch'] = random_fpc_batch

                                self.update_df1_ocr_sort_info.emit(df1_ocr_sort_info)
                                
                                self.ocr_ai_thread_id += 1
                    except Exception as e:

                        print(traceback.print_exc())

                        self.thread2_error_message.emit(e)

                        self.isRunning = False

            self.isRunning = False

            self.thread2_status.emit(self.isRunning)

            if camera_connect_success == True:
                ocr_finish_tm





            
            

                

                

            # while self.isRunning :


            #     time.sleep(0.001)
            #     try:
            #         now = datetime.datetime.now()
            #         if df1_ocr_sort_info.shape[0] > thread2_ocr_ai_thread_id:
            #             image_capture_tm = df1_ocr_sort_info.loc[thread2_ocr_ai_thread_id, 'image_capture_tm']
            #             sensor_off_time = datetime.datetime.strptime(image_capture_tm, '%Y-%m-%d %H:%M:%S:%f')
            #             # print(sensor_off_time)
                
            #             if (datetime.datetime.now() - sensor_off_time).microseconds>= 950000:
                            
            #                 #time.sleep(0.0001)

            #                 '''
            #                 1. 触发相机拍照
            #                 '''
            #                 image, teat = camera.camera_grap_image(self.camera_use)

            #                 '''
            #                 2. 存图
            #                 '''
            #                 now1 = datetime.datetime.now()
            #                 grap_finish_tm = now1.strftime("%Y%m%d%H%M%S%f")
            #                 cv2.imwrite('pic/pic_camera/'+sensor_off_time.strftime("%Y%m%d%H%M%S%f") + '.jpeg', image)
            #                 new_image_name = sensor_off_time.strftime("%Y%m%d%H%M%S%f") + '.jpeg'
            #                 self.new_image_name.emit(new_image_name)
            #                 '''
            #                 3.ocr 推导
            #                 '''
            #                 ocr_result = ocr_ai.infer_image_phase1aphase2(self.predictor, self.reader, image, new_image_name)
            #                 self.ocr_result.emit(ocr_result)
            #                 self.image_ocr_result.emit(new_image_name)
            #                 now = datetime.datetime.now()
            #                 ocr_finish_tm = now.strftime("%Y-%m-%d %H:%M:%S:%f")[:-3]

            #                 '''
            #                 4.ocr结果进行模糊匹配  
            #                 将OCR返回数据放入模糊匹配函数中进行匹配
            #                 目前逻辑：
            #                 4.1.遍历所有ocr结果,组合成ocr_fpc 和 ocr_batch,放入模糊匹配函数进行匹配
            #                 4.2.根据返回的模糊匹配结果,选择最佳结果
            #                 选择原则
            #                 1.优选fpc匹配的字符个数最多的选项
            #                 2.如果fpc匹配的字符个数相同，选择batch字符数匹配多的
            #                 4.3.如果fpc 和 batch匹配的字符数都大于N个,认为ocr识别成功
            #                 '''
            #                 ocr_fuzzy_match = fuzzy_match(ocr_result[0], ocr_result[1], 0.6)
  

            #                 '''
            #                 5.更新df1_ocr_sort_info中 'ocr_finish_tm' 'fpc_num'  'batch_code' 数据列
            #                 '''
            #                 df1_ocr_sort_info.loc[thread2_ocr_ai_thread_id, 'ocr_finish_tm'] = ocr_finish_tm                           
            #                 #df1_ocr_sort_info.loc[thread2_ocr_ai_thread_id, 'fpc_num'] = ocr_fuzzy_match[0]
            #                 #df1_ocr_sort_info.loc[thread2_ocr_ai_thread_id, 'batch_code'] = ocr_fuzzy_match[1]
            #                 df1_ocr_sort_info.loc[thread2_ocr_ai_thread_id, 'fpc_batch'] = ocr_fuzzy_match
            #                 self.update_df1_ocr_sort_info.emit(df1_ocr_sort_info)
            #                 thread2_ocr_ai_thread_id += 1
            #                 print('thread2_time:', datetime.datetime.now() - now1)

            #         '''
            #         if len(df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()]) > 0:
            #             # print(len(df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()]))
            #             # print(df1_ocr_sort_info)
            #             # print(df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()])
            #             image_capture_tm = df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()].iloc[0, 0]
            #             sensor_off_time = datetime.datetime.strptime(image_capture_tm, '%Y%m%d%H%M%S%f')
            #             #print(sensor_off_time)
            #             if (datetime.datetime.now() - sensor_off_time).microseconds > 700000:
            #                 now = datetime.datetime.now()
            #                 ocr_finish_tm = now.strftime("%Y%m%d%H%M%S%f")
            #                 image, teat = camera.camera_grap_image(camera_use)
            #                 cv2.imwrite(ocr_finish_tm+'.jpeg', image)
            #                 # print(df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()].loc[0]['serial_num'])
            #                 serial_num = df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()].iloc[0][-1]
            #                 #mutux.acquire(1)
            #                 df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == serial_num, 'ocr_finish_tm'] = ocr_finish_tm
            #                 #mutux.release()
            #                 print('Thread2 result:',df1_ocr_sort_info)
            #         #print('Thread2 run time:',datetime.datetime.now() - now)
            #                 # df1_ocr_sort_info[df1_ocr_sort_info['ocr_finish_tm'].isna()].loc[0]['ocr_finish_tm'] = ocr_finish_tm
            #         '''

            #         '''
            #         if plc.read_bool(siemens_plc, 1, 1) and program_run_once:
            #             camera.camera_connect(camera_use)
            #             time.sleep(1.4)
            #             program_run_once = False
            #             image, teat = camera.camera_grap_image(camera_use)
            #             cv2.imwrite('Test.jpeg', image)
            #             camera.camera_disconnect(camera_use)
            #             print("Finished_Grap_Image")
            #         elif plc.read_bool(siemens_plc, 1, 1) == 0 and not program_run_once:
            #             program_run_once = True
            #         '''
            #     except Exception:
            #         print(traceback.print_exc())
            #         print("camera grap image  Failure")
            #         # camera_grap_image_success = False
            #         camera.camera_disconnect(self.camera_use)  

        def stop(self):

            self.isRunning = False                   

class thread3_calculate_sorter_output(QtCore.QThread):

    def __init__(self):
        super(thread3_calculate_sorter_output, self).__init__()
        print('thread3 init sucess')

    def run(self):
        global df1_ocr_sort_info,df2_fpc_batch_summary,df3_sorter_output_status

        while True:
            time.sleep(0.001)
            calculate_sorter_output(df1_ocr_sort_info,df2_fpc_batch_summary,df3_sorter_output_status)

class thread4_intralox_plc_message(QtCore.QThread):

    df3_update = QtCore.pyqtSignal(object)
    
    def __init__(self):
        super(thread4_intralox_plc_message, self).__init__()
        
        
        print('thread4 init sucess')

    def get_plc_source(self,plc):
        self.plc = plc   
    
    def run(self):
        global df1_ocr_sort_info, df3_sorter_output_status
        global thread4_case_counter
        thread4_case_counter = 0
        thread4_allocation_num = 0
        intralox_init_serial_num = 0
        intralox_1_OnChute_serial_num = 0
        intralox_2_OnChute_serial_num = 0
        intralox_3_OnChute_serial_num = 0
        intralox_4_OnChute_serial_num = 0
        intralox_5_OnChute_serial_num = 0
        intralox_6_OnChute_serial_num = 0
        intralox_7_OnChute_serial_num = 0
        
        intralox_plc =self.plc
        '''
        intralox plc address configure
        '''
        plc_db_address_intralox_recive = 100
        plc_address_offset_REC_SYSTEM = 0
        plc_address_offset_REC_ID = 2
        plc_address_offset_REC_Destination = 6
        plc_address_offset_REC_ID_Destination = 10

        plc_db_address_intralox_send = 101

        plc_address_offset_SEND_ID_PE = 0
        plc_address_offset_Sorter_ID_OnChute_1 = 4  
        plc_address_offset_Sorter_ID_OnChute_2 = 8  
        plc_address_offset_Sorter_ID_OnChute_3 = 12
        plc_address_offset_Sorter_ID_OnChute_4 = 16
        plc_address_offset_Sorter_ID_OnChute_5 = 20
        plc_address_offset_Sorter_ID_OnChute_6 = 24
        plc_address_offset_Sorter_ID_OnChute_7 = 28
        plc_address_offset_Sorter_ID_End       = 32
        plc_address_offset_SEND_PackageStatus  = 36
        plc_address_offset_SEND_SorterStatus   = 38
        plc_address_offset_SEND_SorterFaulty   = 40
        plc_address_offset_REC_LaneOpen        = 42

        self.df3_update.emit(df3_sorter_output_status)

        while True:
            
            #try:
                #now = datetime.datetime.now()
            '''
            task 1:
            新箱子到时
            写新的流水号至intralox plc 
            '''
            if df1_ocr_sort_info.shape[0] > thread4_case_counter:

                serial_num = df1_ocr_sort_info.loc[thread4_case_counter, 'serial_num']

                plc.write_db_dint(intralox_plc, plc_db_address_intralox_recive, plc_address_offset_REC_ID, serial_num)
                thread4_case_counter += 1
            
            '''
            task 2:
            有新的分配口时
            将新收到的人分配口信息和流水号写至intralox plc 
            '''
            if df1_ocr_sort_info.shape[0] > thread4_allocation_num:
               
               if not pd.isna(df1_ocr_sort_info.loc[thread4_allocation_num, 'sorter_output']):
                   
                   serila_num_allocation = int(df1_ocr_sort_info.loc[thread4_allocation_num, 'serial_num'])

                   sorter_output_allocation = int(df1_ocr_sort_info.loc[thread4_allocation_num, 'sorter_output'])
                   
                   plc.write_db_dint(intralox_plc, plc_db_address_intralox_recive, plc_address_offset_REC_Destination, sorter_output_allocation)

                   plc.write_db_dint(intralox_plc, plc_db_address_intralox_recive, plc_address_offset_REC_ID_Destination, serila_num_allocation)
                   

                   thread4_allocation_num += 1

            '''
            task 3:
            从intralox plc读取到新到的箱子序列号时
            将 系统时间 写入至 df1_ocr_sort_info 中的行数据 = 新箱子的序号号中的 sorter_enter_tm       列中
            将 True   写入至 df1_ocr_sort_info 中的行数据 = 新箱子的序号号中的 sorter_success_enter  列中
            '''
            if  intralox_init_serial_num != plc.read_db_dint(intralox_plc,plc_db_address_intralox_send, plc_address_offset_SEND_ID_PE):

                sorter_enter_tm = datetime.datetime.now().strftime("%Y%m%d%H%M%S")

                intralox_new_serial_num = plc.read_db_dint(intralox_plc,plc_db_address_intralox_send, plc_address_offset_SEND_ID_PE)

                df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_new_serial_num, 'sorter_enter_tm'] = sorter_enter_tm

                df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_new_serial_num, 'sorter_success_enter'] = True

                intralox_init_serial_num = intralox_new_serial_num

            '''
            task 4:
            从intralox plc读取到1#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是1号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_1_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_1):
 
                intralox_1_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_1)

                if not (df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_1_OnChute_serial_num]).empty:
                
                    try:

                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_1_OnChute_serial_num] .iloc[0]['sorter_output'] == '1' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_1_OnChute_serial_num, 'success_sort'] = True

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_1_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_1_OnChute_serial_num + '----错误分至1#口')

                            pass

                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())

            '''
            task 5:
            从intralox plc读取到2#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是2号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_2_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_2):

                intralox_2_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_2)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_2_OnChute_serial_num].empty:

                    try:

                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_2_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '2' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_2_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_2_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_2_OnChute_serial_num + '----错误分至2#口')

                            pass

                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())

                    
                    

            '''
            task 6:
            从intralox plc读取到3#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是3号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_3_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_3):

                intralox_3_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_3)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_3_OnChute_serial_num].empty:

                    try:


                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_3_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '3' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_3_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_3_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_3_OnChute_serial_num + '----错误分至3#口')

                            pass        

                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())

            '''
            task 7:
            从intralox plc读取到4#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是4号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_4_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_4):

                intralox_4_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_4)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_4_OnChute_serial_num].empty:

                    try:


                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_4_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '4' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_4_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_4_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_4_OnChute_serial_num + '----错误分至4#口')

                            pass      
                    
                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())

            '''
            task 8:
            从intralox plc读取到5#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是5号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_5_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_5):

                intralox_5_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_5)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_5_OnChute_serial_num].empty:

                    try:

                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_5_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '5' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_5_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_5_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_5_OnChute_serial_num + '----错误分至5#口')

                            pass       
                    
                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())

            '''
            task 9:
            从intralox plc读取到6#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是6号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_6_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_6):

                intralox_6_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_6)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_6_OnChute_serial_num].empty:

                    try:


                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_6_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '6' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_6_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_6_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_6_OnChute_serial_num + '----错误分至6#口')

                            pass  
                    
                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())
            
            '''
            task 10:
            从intralox plc读取到7#正在分拣的箱子序列号
            如果正在分拣的箱子序列号 不等于 上一个分拣的箱子序列号
            查找箱子序列号对应在 df1_ocr_sort_info 中的 sorter_output 是否是7号口，如果是 
            则将该箱子序列号对在 df1_ocr_sort_info 中的 success_sort 写为 True
            '''
            if intralox_7_OnChute_serial_num != plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_7):

                intralox_7_OnChute_serial_num = plc.read_db_dint(intralox_plc, plc_db_address_intralox_send, plc_address_offset_Sorter_ID_OnChute_7)

                if not df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_7_OnChute_serial_num].empty:
                
                    try:

                        if df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_7_OnChute_serial_num] .iloc[0][ 'sorter_output'] == '7' :

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_7_OnChute_serial_num, 'success_sort'] = True  

                        else:
                            # wait to do
                            # 如果不匹配是否停止分拣？

                            df1_ocr_sort_info.loc[df1_ocr_sort_info['serial_num'] == intralox_7_OnChute_serial_num, 'success_sort'] = True

                            # logging.debug('serial_num:----'+ intralox_7_OnChute_serial_num + '----错误分至7#口')

                            pass    

                    except Exception:

                        #print(traceback.print_exc())

                        logging.debug(traceback.print_exc())                      
 
            '''
            task 11:
            从intralox plc读取 1# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 1 中的 physical_available 中         
            从intralox plc读取 2# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 2 中的 physical_available 中      
            从intralox plc读取 3# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 3 中的 physical_available 中 
            从intralox plc读取 4# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 3 中的 physical_available 中 
            从intralox plc读取 5# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 3 中的 physical_available 中 
            从intralox plc读取 6# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 3 中的 physical_available 中 
            从intralox plc读取 7# 分拣口状态
            写入df3_sorter_output_status 中 'sorter_output' == 3 中的 physical_available 中 
            ''' 

            # 1#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '1'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '1','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,1) 

                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '1'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,1)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '1','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,1) 

                self.df3_update.emit(df3_sorter_output_status)

            # 2#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '2'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '2','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,2) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '2'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,2)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '2','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,2) 

                self.df3_update.emit(df3_sorter_output_status)                
             
             # 3#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '3'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '3','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,3) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '3'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,3)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '3','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,3) 

                self.df3_update.emit(df3_sorter_output_status)            

              # 4#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '4'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '4','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,4) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '4'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,4)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '4','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,4) 

                self.df3_update.emit(df3_sorter_output_status)  

              # 5#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '5'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '5','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,5) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '5'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,4)) :


                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '5','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,5) 

                self.df3_update.emit(df3_sorter_output_status)  

              # 6#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '6'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '6','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,6) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '6'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,6)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '6','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,6) 

                self.df3_update.emit(df3_sorter_output_status)  

              # 7#分拣口物理状态更新

            if pd.isna(df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '7'].iloc[0]['physical_available']):

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '7','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,7) 
        
                self.df3_update.emit(df3_sorter_output_status)

            elif (df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '7'].iloc[0]['physical_available']) != \
                (plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,7)) :

                df3_sorter_output_status.loc[df3_sorter_output_status['sorter_output'] == '7','physical_available'] = \
                plc.read_db_word_bool(intralox_plc,plc_db_address_intralox_send,plc_address_offset_REC_LaneOpen,7) 

                self.df3_update.emit(df3_sorter_output_status) 
            
            time.sleep(0.001)

class thread5_accumulated_cnt_and_sorter_release(QtCore.QThread):

    def __init__(self):
        super(thread5_accumulated_cnt_and_sorter_release, self).__init__()
        print('thread5 init sucess')
    
    def run(self):
        global df2_fpc_batch_summary,df3_sorter_output_status

        while True:
            time.sleep(0.001)
            accumulated_cnt_and_sorter_release(df2_fpc_batch_summary,df3_sorter_output_status)

class thread6_update_df2_df3(QtCore.QThread):

    df1_update = QtCore.pyqtSignal(object)

    df2_update = QtCore.pyqtSignal(object)

    df3_update = QtCore.pyqtSignal(object)

    def __init__(self):
        super(thread6_update_df2_df3, self).__init__()
        print('thread6 init sucess')

    def run(self):
        global df1_ocr_sort_info,df2_fpc_batch_summary,df3_sorter_output_status

        while True:

            time.sleep(2)

            self.df1_update.emit(df1_ocr_sort_info)

            self.df2_update.emit(df2_fpc_batch_summary)

            self.df3_update.emit(df3_sorter_output_status)


class StackedDemo(QtWidgets.QMainWindow, Ui_MainWindow):

    def __init__(self):
        super(StackedDemo, self).__init__()
        self.setupUi(self)  # 创建窗体对象
        self.init()

    def init(self):

        self.menubar.setVisible(True)

        self.statusbar.setVisible(True)

        self.thread1_mode = None

        self.button_login.clicked.connect(self.login)

        self.pushButton1.clicked.connect(self.belt_run)  

        self.pushButton2.clicked.connect(self.belt_stop)  

        self.pushButton3.clicked.connect(self.load_truck_info)

        self.main_page.triggered.connect(self.main_page_display)

        self.button_generate_case.clicked.connect(self.generate_case)

        self.button_save_df1.clicked.connect(self.save_df1)

        self.button_release_sorter.clicked.connect(self.manual_release_sorter)

        self.ocr_plc_configure.triggered.connect(self.ocr_plc_configure_display)

        self.button_phase1_select_mode_1.clicked.connect(self.phase1_select_model1)

        self.button_phase1_select_mode_2.clicked.connect(self.phase1_select_model2)

        self.button_phase1_select_mode_3.clicked.connect(self.phase1_select_model3)

        self.button_phase1_start.clicked.connect(self.phase1_start)

        self.button_phase1_stop.clicked.connect(self.phase1_stop)

        self.thread1 = thread1_ocr_plc_message()

        self.thread1.button_generate_case_visable.connect(self.set_button_generate_case_visable)

        self.thread1.thread1_status.connect(self.update_thread1_status)

        self.thread1.thread1_error_message.connect(self.thread_error_message_display)

        self.page4_button_phase2_select_mode_1.clicked.connect(self.phase2_select_model1)

        self.page4_button_phase2_select_mode_2.clicked.connect(self.phase2_select_model2)

        self.page4_button_phase2_select_mode_3.clicked.connect(self.phase2_select_model3)

        self.page4_button_phase2_start.clicked.connect(self.phase2_start)

        self.page4_button_phase2_stop.clicked.connect(self.phase2_stop)

        self.thread2 = thread2_ocr_ai_thread()   

        self.thread2_mode = None

        self.thread2.thread2_status.connect(self.update_thread2_status)

        self.thread2.thread2_error_message.connect(self.thread_error_message_display)



        self.intralox_plc_configure.triggered.connect(self.page_intralox_plc_configure_display)

        self.ai_ocr_configure.triggered.connect(self.page_ai_module_diplay)

        '''
        AI Module global 变量
        '''
        # path = 'ocr_ai_fodler/module/model_final.pth'
        # batch_size = 32
        # anchor_sizes = [[32, 64, 128, 256, 512]]
        # anchor_ratios = [[0.1, 0.15, 0.2, 0.25, 0.33]]
        # num_classes = 3
        # accept_score = 0.45      

        # '''
        # thread2 start
        # '''  
        # predictor, reader = load_ai_module(path, batch_size, anchor_sizes, anchor_ratios, num_classes, accept_score)
            
        # self.thread2.get_camera_source(camera.get_camera_source())
        # self.thread2.get_ai_module(predictor,reader)
        self.thread2.update_df1_ocr_sort_info.connect(self.update_df1_ocr_sort_info)
        self.thread2.new_image_name.connect(self.image_update)
        self.thread2.ocr_result.connect(self.ocr_result_update)
        self.thread2.image_ocr_result.connect(self.image_ocr_result_update)
        # self.thread2.start()

        '''
        thread3 start
        '''
        self.thread3 = thread3_calculate_sorter_output()
        self.thread3.start()

        """
        连接intralox plc
        """
        self.thread4 = thread4_intralox_plc_message()
        intralox_plc_ip_address = "192.168.0.100"
        connect_type_intralox_plc = 2

        intralox_plc = plc.plc_connect(intralox_plc_ip_address, connect_type_intralox_plc)

        '''
        thread4 start
        '''
        self.thread4.get_plc_source(intralox_plc)
        self.thread4.start()        
        self.thread4.df3_update.connect(self.update_df3_sorter_output_status)

        df3_sorter_output_status

        '''
        thread5 start
        '''
        self.thread5 = thread5_accumulated_cnt_and_sorter_release()
        self.thread5.start()

        '''
        thread6 start
        '''
        self.thread6 = thread6_update_df2_df3()
        self.thread6.df2_update.connect(self.update_df3_sorter_output_status)
        self.thread6.df3_update.connect(self.update_df3_sorter_output_status)
        self.thread6.df1_update.connect(self.update_df1_ocr_sort_info)
        self.thread6.start()

    def login(self):

        if df_user_congfigure.loc[df_user_congfigure['user']==self.page_login_input_user_name.text()].empty:
            QtWidgets.QMessageBox.critical(None, "Error", "Please Input the Correct User Name")
        elif df_user_congfigure.loc[df_user_congfigure['user']==self.page_login_input_user_name.text()].iloc[0]['password'] != self.page_login_input_password.text() :
            QtWidgets.QMessageBox.critical(None, "Error", "The password isn't match the user name")
        else:
            self.stackedWidget.setCurrentIndex(1)
            self.menubar.setVisible(True)
            self.statusbar.setVisible(True)

    def save_df1(self):
        df1_ocr_sort_info.to_csv('./df1_result.csv', index=False)

    def phase1_select_model1(self):
       
        if self.thread1.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase1")

        else:

            self.Q_label_text_phase1_status.setText("<font color = 'blue',>Phase1 Mode: Simualtion with out PLC</font>")

            self.thread1_mode = 1

    def phase1_select_model2(self):

        if self.thread1.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase1")

        else:

            self.Q_label_text_phase1_status.setText("<font color = 'yellow',>Phase1 Mode: Simualtion with PLC</font>")

            self.thread1_mode = 2

    def phase1_select_model3(self):

        if self.thread1.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase1")

        else:

            self.Q_label_text_phase1_status.setText("<font color = 'green',>Phase1 Mode: Production </font>")

            self.thread1_mode = 3

    def set_button_generate_case_visable(self,visable):

        self.button_generate_case.setVisible(visable)

    def generate_case(self):

        self.thread1.generate_case = True

    def update_thread1_status(self,_thread1_status):

        if _thread1_status == True:

            self.Q_label_text_7.setText("<font color = 'green',>Running</font>")
        
        else:

            self.Q_label_text_7.setText("<font color = 'red',>Stopped</font>")

    def phase1_start(self):

        """
        连接OCR PLC
        """
        if self.thread1_mode == None:
            QtWidgets.QMessageBox.critical(None, "Error", "Please select thread1 run Mode.")
        else:
            self.thread1.thread_Mode = self.thread1_mode
            
            if self.thread1_mode != 1 and \
                  (
                      (not re.match(r'\d+.\d+.\d+.\d+',self.line_edit_ocr_plc_address.text())) 
                      or (not re.match(r'\d+',self.line_edit_ocr_plc_address.text()))
                  ): 
                QtWidgets.QMessageBox.critical(None, "Error", "Please input the correct IP Address and correct connect type ")

            elif self.thread1_mode != 1 :    

                self.thread1.plc_connect_type = int(self.line_edit_ocr_plc_connect_type.text())

                self.thread1.plc_ip_address = self.line_edit_ocr_plc_address.text()
                '''
                thread1 start
                '''
            self.thread1.serial_num = 0
            self.thread1.start()        

    def phase1_stop(self):

        self.thread1.isRunning = False

    def phase2_select_model1(self):
       
        if self.thread2.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase2")

        else:

            self.page4_phase2_status.setText("<font color = 'blue',>Phase1 Mode: Simualtion with out AI Model</font>")

            self.thread2_mode = 1

    def phase2_select_model2(self):

        if self.thread2.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase2")

        else:

            self.page4_phase2_status.setText("<font color = 'yellow',>Phase1 Mode: Simualtion with AI Model</font>")

            self.thread2_mode = 2

    def phase2_select_model3(self):

        if self.thread2.isRunning == True:

            QtWidgets.QMessageBox.critical(None, "Error", "Please stop the Phase2")

        else:

            self.page4_phase2_status.setText("<font color = 'green',>Phase1 Mode: Production </font>")

            self.thread2_mode = 3

    def update_thread2_status(self,_thread2_status):

        if _thread2_status == True:

            self.page4_text_6.setText("<font color = 'green',>Running</font>")
        
        else:

            self.page4_text_6.setText("<font color = 'red',>Stopped</font>")

    def phase2_start(self):

        """
        连接OCR PLC
        """
        if self.thread2_mode == None:
            QtWidgets.QMessageBox.critical(None, "Error", "Please select thread2 run Mode.")
        else:
            self.thread2.thread_Mode = self.thread2_mode
  
            if self.thread2_mode == 1 :

                pass

                #QtWidgets.QMessageBox.critical(None, "Error", "Please input the correct IP Address and correct connect type ")

            elif self.thread2_mode == 3 :   

                path = 'ocr_ai_fodler/module/model_final.pth'

                self.thread2.predictor,self.thread2.reader = ocr_ai.load_predictor(str(self.page4_input_text_model_file_path.text()),
                                                                                   int(self.page4_input_text_Model_Batch_Size.text()),
                                                                                   [[int(x) for x in self.page4_input_text_Model_Anchor_Size.text().split(', ')]],
                                                                                   [[float(x) for x in self.page4_input_text_model_anchor_ratios.text().split(', ')]],                                                               
                                                                                   int(self.page4_input_text_ai_ocr_model_setting_num_classes.text()),
                                                                                   float(self.page4_input_text_ai_ocr_model_setting_accept_score.text())
                                                                                   )

                self.thread2.camera = camera.get_camera_source()
                '''
                thread2 start
                '''

            self.thread2.ocr_ai_thread_id = 1

            self.thread2.start()        

    def phase2_stop(self):

        self.thread2.isRunning = False

    def main_page_display(self):

        self.stackedWidget.setCurrentIndex(1)

    def ocr_plc_configure_display(self):

        self.stackedWidget.setCurrentIndex(2)
    
    def page_intralox_plc_configure_display(self):

        self.stackedWidget.setCurrentIndex(3)

    def page_ai_module_diplay(self):

        self.stackedWidget.setCurrentIndex(4)

    def update_df1_ocr_sort_info(self,df1):

        readonly_df = df1.copy(deep=True)

        if df1.shape[0] >= 18:

            readonly_df = df1.tail(18)
        
        model = pandasModel(readonly_df)
        self.tableView1.setModel(model)

    def update_df2_fpc_batch_summary(self,df2):

        readonly_df = df2.copy(deep=True)  

        model = pandasModel(readonly_df)

        self.tableView.setModel(model)       

    def update_df3_sorter_output_status(self,df3):

        readonly_df3 = df3.copy(deep=True)
       
        
        model = pandasModel(readonly_df3)
        self.tableView2.setModel(model)

    def image_update(self,new_image_name):

        pixmap = QtGui.QPixmap('pic//pic_camera//' +new_image_name)
        pix = pixmap.scaled(QtCore.QSize(500, 500), QtCore.Qt.KeepAspectRatio)
        self.image_raw.setPixmap(pix)
        self.image_raw.setAlignment (QtCore.Qt.AlignCenter)

    def image_ocr_result_update(self,image_ocr_result):

        pixmap = QtGui.QPixmap('pic//pic_ocr_result//' + image_ocr_result)
        pix = pixmap.scaled(QtCore.QSize(540, 540), QtCore.Qt.KeepAspectRatio)
        self.image_result.setPixmap(pix)
        self.image_result.setAlignment (QtCore.Qt.AlignCenter)

    def ocr_result_update(self,ocr_result):
        ocr_result_str = '' 
        for item in ocr_result:
            for str in item:
               ocr_result_str = ocr_result_str +'_' + str
        self.textEdit_ocr_result.setText(ocr_result_str)
        # self.textEdit_ocr_result.setText("<font color = 'white' >ocr_result_str</font>")
        self.textEdit_ocr_result.setStyleSheet("color: white;")
        self.textEdit_ocr_result.setFont(QtGui.QFont('Times', 12))
        

    def belt_run(self):
        ocr_ip_address = "192.168.3.10"
        connect_type_ocr = 2

        try:
            ocs_siemens_plc = plc.plc_connect(ocr_ip_address, connect_type_ocr)
            plc.write_bool(ocs_siemens_plc, 1, 0, 1)
            plc.plc_con_close(ocs_siemens_plc)

        except Exception as e:
                QtWidgets.QMessageBox.critical(None, "Error", f"Error: {e}")
       
    def belt_stop(self):
        ocr_ip_address = "192.168.3.10"
        connect_type_ocr = 2
        try:
            ocs_siemens_plc = plc.plc_connect(ocr_ip_address, connect_type_ocr)
            plc.write_bool(ocs_siemens_plc, 1, 0, 0)
            plc.plc_con_close(ocs_siemens_plc)
        except Exception as e:
                QtWidgets.QMessageBox.critical(None, "Error", f"Error: {e}")
    
    def thread_error_message_display(self,e):

        QtWidgets.QMessageBox.critical(None, "Error", f"Error: {e}")

    def load_truck_info(self):
            global df2_fpc_batch_summary
            global df1_ocr_sort_info
            global thread2_ocr_ai_thread_id
            #file_name, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Open etx File", "", "xlsx File(*.xlsx);;etx File(*.etx);;csv file(*.csv)")
            file_name, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Open etx File", "", "csv file(*.csv)")
            if not file_name:
                QtWidgets.QMessageBox.critical(None, "Error", "Please select an etx file to read.")
                return
            try:

                #df=pd.load(file_name, col_name=None,sheetname='Sheet1',engine="polars")
                df2_fpc_batch_summary_temp = pd.read_csv(file_name)

                df2_fpc_batch_summary = df2_fpc_batch_summary_temp.reindex(columns = df2_fpc_batch_summary_temp.columns.tolist()+ ["actual_qty","completion",'last_enter_tm','sorter_output','waited_tm'])
                new_row = pd.Series({'fpc_batch': 'others','target_qty': 9999, 'actual_qty': 0,'completion':'N'})
                df2_fpc_batch_summary.loc[:,'actual_qty'] = 0
                df2_fpc_batch_summary.loc[:,'completion'] = "N"
                df2_fpc_batch_summary = pd.concat([df2_fpc_batch_summary, new_row.to_frame().T], ignore_index=True)
                df2_fpc_batch_summary['target_qty'] = df2_fpc_batch_summary['target_qty'].astype(int)
                df2_fpc_batch_summary['actual_qty'] = df2_fpc_batch_summary['actual_qty'].astype(int)
                model = pandasModel(df2_fpc_batch_summary)
                self.tableView.setModel(model)
                df1_ocr_sort_info = df1_ocr_sort_info.drop(index=range(len(df1_ocr_sort_info)))
                thread2_ocr_ai_thread_id = 0
                model = pandasModel(df1_ocr_sort_info)
                self.tableView1.setModel(model)     

                self.thread4 = thread4_intralox_plc_message()
                intralox_plc_ip_address = "192.168.0.100"
                connect_type_intralox_plc = 2

                intralox_plc_init = plc.plc_connect(intralox_plc_ip_address, connect_type_intralox_plc)

                plc.write_db_word_bool(intralox_plc_init,100,0,2,1)

                time.sleep(0.1)
                
                plc.write_db_word_bool(intralox_plc_init,100,0,2,0)

                plc.plc_con_close(intralox_plc_init)




            except Exception as e:
                QtWidgets.QMessageBox.critical(None, "Error", f"Error: {e}")
    
    def manual_release_sorter(self):

        global df3_sorter_output_status

        try:

            df3_sorter_output_status.loc[self.select_release_sorter.currentIndex(),'logic_available'] = True
                                       
        except Exception as e:
                QtWidgets.QMessageBox.critical(None, "Error", f"Error: {e}")
                 



if __name__ == '__main__':
    #thread1 = threading.Thread(target=TestThread)
    #thread1.start()
    app = QtWidgets.QApplication(sys.argv)
    ui = StackedDemo()
    ui.show()
    sys.exit(app.exec_())